package org.lilian.grammars;


import java.io.*;
import java.util.*;

import org.lilian.grammars.Grammar;
import org.lilian.grammars.Parse;
import org.lilian.models.*;
import org.lilian.models.old.FrequencyTable;
import org.lilian.util.*;
import org.lilian.util.trees.Tree;
import org.lilian.*;


/**
 * This class represents a probabilistic grammar. It stores rewrite rules with 
 * frequencies.
 * 
 * Note. The Type T used for symbols should have proper equals() and hashCode() 
 * implementations. 
 * 
 * TODO:
 * <ul>
 * <li /> Use an internal <pre>CNFProbabilityGrammar<Constituent></pre> for the CNF rules and 
 * the parse object.
 * <li /> Use a ToCNFWrapper for the Chomsky Normal Form translation.
 * <li /> FIXME: Fix generateSentence/generateTree for no topSymbol 
 * </ul>
 * @param <T>
 */

public class PCFGrammar<T> implements Grammar<T> {
	/* This class implements a basic PCFG grammar.
	 * 
	 *** Introduction 
	 * 
	 * Trees are added to the grammar, one production rule at the time. For 
	 * these rules, frequencies are counted: the frequency of the whole rule, and 
	 * the frequency of the symbol on the left side of the production 'arrow' 
	 * (usually referred to as the 'from' symbol).
	 * 
	 * Over a whole corpus, these frequencies represent a probability 
	 * distribution over all grammatical sentences, where the probability of a 
	 * production is the frequency of the rule divided by the frequency of the 
	 * from-symbol.
	 * 
	 * The parser included in the grammar is a CKY-parser, which means that the 
	 * grammar needs to be converted to Chomsky Normal Form (CNF; binary production 
	 * rules from non-terminals to non-terminals, unary production rules from 
	 * non-terminals to terminals). This is generated by 'lazy initialization'. 
	 * Ie. When a parse is requested, an internal CNF version is generated. If 
	 * rules are added afterward, a new CNF version will be generated.
	 * 
	 * Additional functionality includes the generation of random sentences.
	 * 
	 *** Construction
	 * 
	 * This class is a kind of microcosm of internal classes and collections. The 
	 * basics are as follows:
	 * 
	 * * Constituents:
	 * 		These are the basic units, representing the symbols in rewrite grammars
	 * 		There are two flavors: the RegularConstituent, each of which contains 
	 * 		a T token, and the TempConstituent, which does not contain any outside 
	 * 		symbol, but is used to create the Chomsky Normal Form of the grammar
	 * 		The abstract class Constituent is superclass to both
	 * * Rules
	 * 		These tie the constituens together in production rules. The regular 
	 * 		rule ties a single constituent to a sequence of other constituents. 
	 * 		The CNFRule follows Chomsky Normal Form.
	 * * Collections
	 * 		The rules are collected in a large number of Collections to facilitate 
	 * 		various lookups. These are	defined from line 74.   
	 * * Parse
	 * 		As defined by the Grammar interface there is a parse object that 
	 * 		implements a CKY parser.
	 */
	
	/* Regular Rules */
	/* maps constituents to all rules that have them on the left */
	private LinkedHashMap<Constituent, Set<Rule>> fromMap = 
		new LinkedHashMap<Constituent, Set<Rule>>();
	
	/* Stores the frequencies of rules */
	private FrequencyTable<Rule> rules = 
		new FrequencyTable<Rule>();
	private FrequencyTable<RegularConstituent> constituents = 
		new FrequencyTable<RegularConstituent>();
	
	/* CNF rules */
	
	/* maps constituents to all rules that have them on the right as the single
	 * constituent (these have to be terminal rules) */
	private LinkedHashMap<Constituent, Set<CNFRule>> oneSymbolMap;
	
	/* maps constituents to rules where they occur as the left 'to' symbol */
	private LinkedHashMap<Constituent, Set<CNFRule>> leftSymbolMap;
	
	/* maps constituents to rules where they occur as the right 'to' symbol */	
	private LinkedHashMap<Constituent, Set<CNFRule>> rightSymbolMap;
	
	/* maps two constituents to all rules that have them on the right */
	private LinkedHashMap<Pair<Constituent, Constituent>, Set<CNFRule>> twoSymbolMap;
	
	/* maps constituents to all rules that have them on the left */
	private LinkedHashMap<Constituent, Set<CNFRule>> fromMapCNF;
	
	/* Store the frequencies of rules and constituents*/
	private FrequencyTable<CNFRule> rulesCNF;
	private FrequencyTable<Constituent> constituentsCNF;
	
	private boolean depthLimit;
	
	/* The number of temporary constituents that have been made for the CNF 
	 * version of the grammar */ 	
	private int tempConstituents = 0;
	
	/* Increments every time a modification to this grammar is made */
	private int modCount = 0;
	
	/* The modcount the last time the CNF version was generated. If this differs 
	 * from modCount, the CNF version needs to be regenerated. */
	private int lastCNFModCount = -1;
		
	/**
	 */
	public PCFGrammar(){
	}
	
	/**
	 * Generate a random sentence from this grammar.
	 * 
	 *  @param maxDepth	The maximum depth of the tree generating the sentence.
	 */
	public Collection<T> generateSentence(int minDepth, int maxDepth)
	{
		RegularConstituent symbol = constituents.randomToken();
		
		return generateSentence(symbol.getValue(), minDepth, maxDepth);
	}
	
	/**
	 * Generate a random sentence from this grammar for a given top symbol.
	 * 
	 *  @param maxDepth	The maximum depth of the tree generating the sentence.
	 *  @param maxDepth The top symbol of the sentence.
	 */	
	public Collection<T> generateSentence(T topSymbol, int minDepth,  int maxDepth)
	{
		Tree<T> tree = generateTree(topSymbol, minDepth, maxDepth, null);
		
		return tree.getLeaves();
	}
	
	@Override
	public Tree<T> generateTree(T topSymbol, int minDepth,  int maxDepth, Random random)
	{
		/* Validate the input */
		if (maxDepth < 0)
			throw new IllegalArgumentException("maxDepth (" + maxDepth + ") should be positive");
			
		if (maxDepth == 0)
		{
			depthLimit = false;
			maxDepth = -1;
		} else
			depthLimit = true;

		
		Tree<Constituent> tree = new Tree<Constituent>(new RegularConstituent(topSymbol));
		int depth = generateTreeInner(tree.getRoot(), 0, minDepth, maxDepth, random);
		if(depth == -1)
			return null;
		
		Tree<T> outTree = reconstruct(tree);
			
		return outTree;
	}

	@Override
	public Tree<T> generateTree(int minDepth, int maxDepth, Random random)
	{
		RegularConstituent symbol = constituents.randomToken();
		// System.out.println("Chose topsymbol: " + symbol);
		
		return generateTree(symbol.getValue(), minDepth, maxDepth, random);
	}
	
	/**
	 * Generates a parse tree (a collection of terminal symbols) from
	 * topSymbol (with maximum depth maxDepth). If no sentences for 
	 * the given depth can be created, it returns null.
	 *  
	 * @param symbol
	 * @param maxDepth
	 * @return the depth of the deepest node in the generated subtree
	 */
	private int generateTreeInner(Tree<Constituent>.Node parent, int depth, int minDepth, int maxDepth, Random random)
	{
		Constituent symbol = parent.getValue();
		
// System.out.println(depth + ": " + "Adding symbols to _" + symbol + "_ ");		
// if(symbol.toString().equals("NPp"))
//	System.out.println(depth + ": " + "**** NPp " + isTerminal(symbol));
	
		/* if the symbol is a terminal we end the recursion */
		if(isTerminal(symbol))
			return depth;
		
		/* If we're too deep, we end the recursion */
		if(depth >= maxDepth && depthLimit)
			return -1;

// System.out.println(depth + ": " + " Continuing with " + parent.getValue());		
		
		Set<Rule> fullRules;
		if(fromMap.containsKey(symbol))
			fullRules = fromMap.get(symbol);
		else
			fullRules = Collections.emptySet();
		
		Set<Rule> rules = new LinkedHashSet<Rule>(fullRules);
		
		Rule rule;
		Tree<Constituent>.Node child;
		ArrayList<Tree<Constituent>.Node> children = 
			new ArrayList<Tree<Constituent>.Node>();
		boolean ruleAdded = false, succeeded = true;
		int deepestNode = 0, deepestNodeTotal = 0;
		
		while (rules.size() > 0)
		{
			/* pick a rule at random */
			rule = chooseRule(rules, random);
// System.out.println(depth + ": " + " Using rule " + rule);			
		
			/* call this function for all constituents on the right
			 * of the rule */
			succeeded = true;
			for (Constituent constituent: rule.getTo())
			{
				child = parent.addChild(constituent);
				
				deepestNode = generateTreeInner(child , depth + 1, minDepth, maxDepth, random);
				deepestNodeTotal = Math.max(deepestNode, deepestNodeTotal);
				
				children.add(child);
//System.out.println(depth + ": " + constituent + " " + deepestNode);				
				
				/* 
				 * If deepestNode is -1, the subtree has ended in a non-terminal  
				 */
				if (deepestNode == -1)
				{
//System.out.println(depth + ": " + "removing");					
					for(Tree<Constituent>.Node node : children)
						node.remove();
					rules.remove(rule);
					children.clear();
					
					succeeded = false;
					break;
				}
			}
			
			/* if all the constituents in the rule were successfully added, we've
			 * got ourselves a sentence and we will escape the loop	 */
			
			if(succeeded)
			{
				ruleAdded = true;				
				break;
			}
		}

//if(! ruleAdded)
//	System.out.println("! " + parent.getValue() + " failed");		
		
		return ruleAdded ? deepestNodeTotal : -1;
	}
	
	/**
	 * Chooses a rule at random from a set of rules.
	 * 
	 * The choice is based on rule probability, according to this grammar.
	 * 
	 * @param rules The set of rules to choose from 
	 */
	private Rule chooseRule(Set<Rule> rules, Random random)
	{
		/* This will hold the probabilities of the rules */ 
		double[] probs = new double[rules.size()];
		
		/* We will transfer the rules to a vector to access them by index quickly */
		Vector<Rule> rulesVector = new Vector<Rule>(rules.size());
		
		Iterator<Rule> it = rules.iterator();
		double total = 0.0;
		
		/* Fill the probabilities array and the rules Vector */
		for(int i = 0; it.hasNext(); i++)
		{
			rulesVector.add(it.next());
			probs[i] = getProbability(rulesVector.get(i));
			total += probs[i];
		}
		
		/* normalize the probabilities */
		for(int i = 0; i < probs.length;i++)
			probs[i] = probs[i] / total;
		
		double draw = random == null ? 
				Global.random.nextDouble() : random.nextDouble();
		
		double runningTotal = 0.0;
		int i = -1;

		/* Sum the probabilities until the sum becomes larger than the draw. The 
		 * rule whose probability pushes the sum over the draw is the rule we 
		 * choose. */
		while(runningTotal <= draw)
		{
			i++;			
			runningTotal += probs[i];
		}
		
		return rulesVector.get(i);
	}
	
	
	/**
	 * Get the probability for this Rule
	 *
	 * @param rule The rule
	 * @return The probability for this rule according to this PCFG
	 */
	private double getProbability(Rule r)
	{
		/* Retrieve the frequency of the whole rule */
		double ruleFreq = rules.getFrequency(r);
		
		/* Retrieve the frequency of the 'from' constituent. */
		double fromFreq = constituents.getFrequency(r.getFrom());

		/* avoid div by 0 */
		if(fromFreq == 0.0)
			return 0.0;

		/* The probability of the rule is the frequency of the rule divided by 
		 * the frequency of the 'from' constituent. */ 
		double probability = ruleFreq / fromFreq;
		
		return probability;
	}
	
	/**
	 * Get the probability for this CNF Rule
	 *
	 * @param rule The rule
	 * @return an estimate of the probability for this rule.
	 */
	private double getProbability(CNFRule r)
	{
		toCNF();
		double ruleFreq = rulesCNF.getFrequency(r);
		double fromFreq = constituentsCNF.getFrequency(r.getFrom());

		/* Avoid division by 0 */			
		if(fromFreq == 0.0)
			return 0.0;

		return ruleFreq / fromFreq;
	}
	
	/**
	 * Add a rule to the grammar with frequency 1.0.
	 * 
	 * For a string-based grammar, the rule "S" -> "NP", "VP" would be added as
	 * <code>
	 * Vector<String> to = new Vector<String>();
	 * to.add("NP");  
	 * to.add("VP");
	 * 
	 * grammar.addRule("S", to);
	 * </code>
	 * 
	 * The order of the to symbols is determined by the order in which the 
	 * collection's iterator returns them. 
	 * 
	 * @param from The single symbol that determines the 'from' part of a 
	 * 		production rule
	 * @param to The sequence of symbols that the from symbol is rewritten to.
	 */
	public void addRule(T from, Collection<? extends T> to) 
	{
		addRule(from, to, 1.0, true);
	}

	/**
	 * Adds a rule, as {@link #addRule(Object, Collection)}, but specifies a 
	 * frequency. This frequency is added to the existing frequency the grammar
	 * has for the rule.
	 * 
	 * @param from The single symbol that determines the 'from' part of a 
	 * 		production rule
	 * @param to The sequence of symbols that the from symbol is rewritten to.
	 */
	public void addRule(T from, Collection<? extends T> to, double freq) 
	{
		addRule(from, to, freq, true);
	}
	
	/**
	 * Adds a rule, as {@link #addRule(Object, Collection)}, but specifies a 
	 * frequency, to replace the existing frequency. 
	 * 
	 * @param from The single symbol that determines the 'from' part of a 
	 * 		production rule
	 * @param to The sequence of symbols that the from symbol is rewritten to.
	 */	
	public void setRule(T from, Collection<? extends T> to, double freq) 
	{
		addRule(from, to, freq, false);
	}
	
	/**
	 * The private function that handles adding rules to the grammar.
	 * 
	 * @param from0
	 * @param to0
	 * @param freq The specified frequency
	 * @param increment Whether to increment the existing frequency with the 
	 * 		given value. If increment is false, the existing value is replaced 
	 * 		by <code>frequency</code>. 
	 */
	private void addRule(T from0, Collection<? extends T> to0, double freq, boolean increment)
	{
		/* This modifies the grammar, so the modCount must be incremented */
		modCount++;
		
		/* Create a new vector of RegularConstituents to store in place of the 
		 * given collection */
		Vector<RegularConstituent> to = new Vector<RegularConstituent>();
		for(T token : to0)
			to.add(new RegularConstituent(token));
		
		
		RegularConstituent from = new RegularConstituent(from0);
		
		Rule rule = new Rule(from, to);

		if (increment) 	this.rules.incrementFrequency(rule, freq);
		else 			this.rules.addFrequency(rule, freq);
		
		if (increment) 	constituents.incrementFrequency(rule.getFrom(), freq);
		else
		{
			constituents.addFrequency( rule.getFrom(), 
				constituents.getFrequency(rule.getFrom()) - rules.getFrequency(rule) );
			constituents.incrementFrequency(rule.getFrom(), freq);
		}
		
		// add the rule to the 'from' map
		Set<Rule> rules;
		if (fromMap.containsKey(rule.getFrom()))
		{
			fromMap.get(rule.getFrom()).add(rule);			
		} else
		{
			rules = new LinkedHashSet<Rule>();
			rules.add(rule);
			fromMap.put(rule.getFrom(), rules);						
		}				
	}
	
	/**
	 * Creates the CNF version of this grammar to parse with.
	 * 
	 */
	private void toCNF()
	{
		/* This method generates the CNF version of the grammar. In a CNf version, 
		 * the grammar, all rules must be of the type A -> B, C (binary production 
		 * from non-terminal to non-terminals) or D -> e (unary production from 
		 * non-terminal to terminal).
		 * 
		 * We have two types of rules that need to be modified to turn this grammar 
		 * into CNF:
		 * 
		 * Rules with more than two symbols on the right: A -> B, C, D
		 * 	These are simple to deal with. We introduce a new temporary constituent
		 * 	Xi, where i is an incrementing integer to ensure that all temporary 
		 *  constituents are unique. The example above becomes the two rules 
		 *  A -> X1, D and X1 -> B, C. If the original rule had frequency f, then 
		 *  both these new rules have frequency f as well.
		 *  
		 * Unary production rules: A -> B
		 * 	These are more difficult to deal with. We will take care of the other 
		 * 	rules first, so we have a CNF version that still contains unary rules.
		 *  For the example above, we need to replace all occurrences of A on the 
		 *  right hand side of any rule with all possible productions for B for B.
		 *  For instance, if the grammar contains these rules (frequencies in 
		 *  lowercase):
		 *  A -> B			a
		 *  K -> L, A		k
		 *  M -> A, N		m
		 *  B -> O, P		b1
		 *  B -> Q, R		b2
		 *  
		 *  Then, to remove the rule A -> B we need to add the rules
		 *  K -> L, O, P
		 *  K -> L, Q, R
		 *  M -> O, P, N
		 *  M -> Q, R, N
		 *  
		 * 	Each of which will require an additional temporary constituent, to turn
		 * 	it into a binary rule. Except for A -> B, all the rules from the 
		 * 	original grammar remain. 
		 *   
		 * Note that temporary constituents can be removed from a parse, but unary 
		 * production cannot be reconstructed. These are essentially removed from
		 * the grammar. 
		 */
		
		
		/* Check if the existing CNF version is up to date 
		 * (if so, don't re-generate it) */
		if(lastCNFModCount == modCount)
			return;
		
		/* Clear the current CNF version of the grammar */
		oneSymbolMap = new LinkedHashMap<Constituent, Set<CNFRule>>();
		twoSymbolMap = new LinkedHashMap<Pair<Constituent, Constituent>, Set<CNFRule>>();
		leftSymbolMap  = new LinkedHashMap<Constituent, Set<CNFRule>>();
		rightSymbolMap = new LinkedHashMap<Constituent, Set<CNFRule>>();
		fromMapCNF = new LinkedHashMap<Constituent, Set<CNFRule>>();
		rulesCNF = new FrequencyTable<CNFRule>();
		constituentsCNF = new FrequencyTable<Constituent>();
		
		/* Reset the lastCNFModCount */ 
		lastCNFModCount = modCount;
		
		/* The variables we will use during iteration */
		Rule rule;
		CNFRule cnfRule;
		Iterator<Rule> ruleIt = rules.tokenIterator();
		
		List<Constituent> to;
		ListIterator<Constituent> toIt;
		
		Constituent from, to2, current;
		TempConstituent tc;
		
		/* Deal with rules that have more than two symbols on the right */
		while (ruleIt.hasNext())
		{
			rule = ruleIt.next();

			/* Get the frequency */
			double freq = rules.getFrequency(rule);
			
			/* Iterate over all 'to' symbols */ 
			to = new Vector<Constituent>(rule.getTo());

			/* if the rule has terminals and on the right and is not unary (A -> t),
			 * create new rules. */
			if(rule.getTo().size() > 1)
			{
				toIt = to.listIterator();
				while(toIt.hasNext())
				{
					current = toIt.next();
					if(isTerminal(current))
					{
						tc = new TempConstituent();
						toIt.set(tc);
						cnfRule = new CNFRule(tc, current, null);

						addCNFRule(cnfRule, freq, true);
					}				
				}
			}
			
			// if the rule has > 2 symbols on the right, create new rules 
			from = rule.getFrom();			
			while(to.size() > 2)
			{
				to2 = to.remove(to.size()-1);
				tc = new TempConstituent();
				cnfRule = new CNFRule(from, tc, to2);
		
				addCNFRule(cnfRule, freq, true);
				from = tc;
			}
			
			if(to.size() > 1)		
				cnfRule = new CNFRule(from, to.get(0), to.get(1));
			else
				cnfRule = new CNFRule(from, to.get(0), null);
			
			addCNFRule(cnfRule, freq, true);
		}
		
		/* Deal with unary production rules that do not end in terminals:
		 * For all unary production rules A -> B, we need to transform
		 * the grammar so that it remains equivalent, but it does not contain B
		 * anymore. That means that if we have the rules B -> DE and B -> EF, we
		 * create the new rules A -> DE and B -> EF */
		
		/* this will contain all the symbols we want eliminated */
		Set<Constituent> rollup = new LinkedHashSet<Constituent>();
		
		/* fill rollup with all non-terminal constituents that occur
		   at the right in a unary rule */
		Iterator<Set<CNFRule>> setIt = oneSymbolMap.values().iterator();
		Set<CNFRule> set;
		Iterator<CNFRule> cnfRuleIt;
		CNFRule unaryRule;
		
		while(setIt.hasNext())
		{
			set = setIt.next();
			cnfRuleIt = set.iterator();
			while(cnfRuleIt.hasNext())
			{
				unaryRule = cnfRuleIt.next();
				if(! isTerminal(unaryRule.getTo1()))
					rollup.add(unaryRule.getTo1());				
			}
		}
		
		/* Roll up all constituents in rollup */
	
		CNFRule newRule, newRule2;
		Set<CNFRule> topSet, subSet;
		
		Set<CNFRule> toRemove;
		
		double freq;
		int n;
		
		/* iterate over all constituents C that need to be removed 
		 * For a unary production rule A -> C, we use "toprules": X -> C
		 * and "subrules": C -> Y. 
		 * */
		for(Constituent constituent : rollup)
		{
			/* the rules to be removed when all the new rules have been created */
			toRemove = new LinkedHashSet<CNFRule>();
			
			/* Retrieve the set of rules with constituent C on the left (subrules)*/ 
			subSet = fromMapCNF.get(constituent);
			if(subSet == null)
				subSet = Collections.emptySet();
			
			/* The number of subrules */ 
			n = subSet.size();
			
			/* For all subrules ... */ 
			for(CNFRule subRule : subSet)
			{
				toRemove.add(subRule);		

				/* Iterate over all rules prodcue the single symbol C*/
				topSet = oneSymbolMap.get(constituent);
				if(topSet == null)
					topSet = Collections.emptySet();
				
				for(CNFRule topRule : topSet)
				{
					freq = rulesCNF.getFrequency(topRule);
					
					/* create a new rule */
					newRule = new CNFRule(topRule.getFrom(), subRule.getTo1(), subRule.getTo2());
					/* and add it with the old frequency, divided by the number of new rules .*/ 					
					addCNFRule(newRule, freq / n, true);
					
					toRemove.add(topRule);
				}
				
				/* Iterate over all rules that produce the symbol C, and another symbol */
				topSet = leftSymbolMap.get(constituent);
				if(topSet == null)
					topSet = Collections.emptySet();
				
				for(CNFRule topRule : topSet)
				{
					freq = rulesCNF.getFrequency(topRule);
					if(subRule.getTo2() == null)
					{
						newRule = new CNFRule(topRule.getFrom(), subRule.getTo1(), topRule.getTo2());
						addCNFRule(newRule, freq/n, true);
					}
					else
					{
						tc = new TempConstituent();
						newRule = new CNFRule(topRule.getFrom(), tc, topRule.getTo2());
						newRule2 = new CNFRule(tc, subRule.getTo1(), subRule.getTo2());
						addCNFRule(newRule, freq/n, true);
						addCNFRule(newRule2, freq/n, true);
					}
					toRemove.add(topRule);
				}
				
				/* Iterate over all rules that produce another symbol and the symbol C */				
				topSet = rightSymbolMap.get(constituent);
				if(topSet == null)
					topSet = Collections.emptySet();

				for(CNFRule topRule : topSet)
				{

					freq = rulesCNF.getFrequency(topRule);
					if(subRule.getTo2() == null)
					{
						newRule = new CNFRule(topRule.getFrom(), topRule.getTo1(), subRule.getTo1());
						addCNFRule(newRule, freq/n, true);
					}
					else
					{
						tc = new TempConstituent();
						newRule = new CNFRule(topRule.getFrom(), topRule.getTo1(), tc);
						newRule2 = new CNFRule(tc, subRule.getTo1(), subRule.getTo2());
						addCNFRule(newRule, freq/n, true);
						addCNFRule(newRule2, freq/n, true);						
					}
					toRemove.add(topRule);
				}
			}
			
			
			/* Remove the rules that were marked to be removed */
			for(CNFRule removeRule : toRemove) 
				removeCNFRule(removeRule);			

		}
	}
	
	/**
	 * Removes a rule from all CNF collections
	 * 
	 * @param rule The rule to remove
	 */
	private void removeCNFRule(CNFRule rule)
	{

		if(rule.getTo2() == null)
		{
			oneSymbolMap.get(rule.getTo1()).remove(rule);
		}else
		{
			leftSymbolMap.get(rule.getTo1()).remove(rule);
			rightSymbolMap.get(rule.getTo2()).remove(rule);
		
			Pair<Constituent, Constituent> key;
			key = new Pair<Constituent, Constituent>(rule.getTo1(), rule.getTo2());
			twoSymbolMap.get(key).remove(rule);
		}
		
		fromMapCNF.get(rule.getFrom()).remove(rule);
		
		constituentsCNF.addFrequency(rule.getFrom(), 
				constituentsCNF.getFrequency(rule.getFrom()) - rulesCNF.getFrequency(rule));
		
		rulesCNF.remove(rule);
	}
	
	/**
	 * Adds a CNF rule to the model
	 * 
	 * @param rule
	 * @param freq
	 * @param increment Whether to increment the frequency. If false, the existing 
	 * 	frequency for this rule is replaced by the given frequencys 
	 */
	private void addCNFRule(CNFRule rule, double freq, boolean increment)
	{
		/* The rule may have a terminal at to1 or to2, if so, we need another 
		 * tempconst.
		 * It's not very pretty to do this here, but it works */ 
		if(isTerminal(rule.getTo1()) && rule.getTo2() != null)
		{
			TempConstituent tc = new TempConstituent();
			CNFRule newRule = new CNFRule(tc, rule.getTo1(), null);
			addCNFRule(newRule, freq, increment);
			rule = new CNFRule(rule.getFrom(), tc, rule.getTo2());
		}
		
		if(rule.getTo2() != null &&  isTerminal(rule.getTo2()))
		{
			TempConstituent tc = new TempConstituent();
			CNFRule newRule = new CNFRule(tc, rule.getTo2(), null);
			addCNFRule(newRule, freq, increment);
			rule = new CNFRule(rule.getFrom(), rule.getTo1(), tc);
		}

		/* check for temp constituents */
		if(isTempConst(rule.getFrom()))
			((TempConstituent)rule.getFrom()).setFromRule(rule);
		if(isTempConst(rule.getTo1()))
			((TempConstituent)rule.getTo1()).setToRule(rule);
		if(isTempConst(rule.getTo2()))
			((TempConstituent)rule.getTo2()).setToRule(rule);
		
		if(increment) 	this.rulesCNF.incrementFrequency(rule, freq);
		else 			this.rulesCNF.addFrequency(rule, freq);
		
		if(increment) 	constituentsCNF.incrementFrequency(rule.getFrom(), freq);
		else
		{
			constituentsCNF.addFrequency(rule.getFrom(), 
				constituentsCNF.getFrequency(rule.getFrom()) - rulesCNF.getFrequency(rule));
			constituentsCNF.incrementFrequency(rule.getFrom(), freq);
		}
		
		// add the rule to the 'from' map
		Set<CNFRule> rules;
		if(fromMapCNF.containsKey(rule.getFrom()))
		{
			fromMapCNF.get(rule.getFrom()).add(rule);			
		}else
		{
			rules = new LinkedHashSet<CNFRule>();
			rules.add(rule);
			fromMapCNF.put(rule.getFrom(), rules);						
		}
		
		if(rule.getTo2() == null)
		{
			// add the rule to the map for one symbol
			if(oneSymbolMap.containsKey(rule.getTo1()))
			{
				oneSymbolMap.get(rule.getTo1()).add(rule);			
			}else
			{
				rules = new LinkedHashSet<CNFRule>();
				rules.add(rule);
				oneSymbolMap.put(rule.getTo1(), rules);						
			}
		}else
		{
			// add the rule to the map for two symbols
			Pair<Constituent, Constituent> key = 
				new Pair<Constituent, Constituent>(rule.getTo1(), rule.getTo2());
			if( twoSymbolMap.containsKey(key) ){
				twoSymbolMap.get(key).add(rule);			
			}else
			{
				rules = new LinkedHashSet<CNFRule>();
				rules.add(rule);
				twoSymbolMap.put(key, rules);						
			}
			
			// add the rule to the map for its left 'to' symbol 
			if(leftSymbolMap.containsKey(rule.getTo1()))
			{
				leftSymbolMap.get(rule.getTo1()).add(rule);			
			}else
			{
				rules = new LinkedHashSet<CNFRule>();
				rules.add(rule);
				leftSymbolMap.put(rule.getTo1(), rules);						
			}
			
			// add the rule to the map for its right 'to' symbol 
			if(rightSymbolMap.containsKey(rule.getTo2()))
			{
				rightSymbolMap.get(rule.getTo2()).add(rule);			
			}else
			{
				rules = new LinkedHashSet<CNFRule>();
				rules.add(rule);
				rightSymbolMap.put(rule.getTo2(), rules);						
			}			
		}		
	}
	
	
	/**
	 * Creates csv files for frequencies and probabilities of rules
	 *
	 * The list of rules and probabilities is
	 * generated on the fly, so this method has O(n) or worse performance.
	 *
	 * @param base The base for the filename to use
	 */
	public void write(File directory, String base) throws IOException
	{
		//write out the frequency tables
		rules.writeResults(directory, base + ".PCFG.rules");
		constituents.writeResults(directory, base + ".PCFG.constituents");

		// create a list of rules and their probabilities
		List<RuleProbability> sorted =
			new ArrayList<RuleProbability>();

		// iterate over all the rules, adding them and their probabilities
		// to the map
		Iterator<Rule> it = rules.tokenIterator();

		while(it.hasNext())
			sorted.add( new RuleProbability(it.next()) );

		Collections.sort(sorted);

		// write the list to a text file

		BufferedWriter out = new BufferedWriter(new FileWriter(
				new File(directory,  base + ".PCFG.probabilities " + ".csv")));

		ListIterator<RuleProbability> it2 = sorted.listIterator(sorted.size()-1);

		RuleProbability rp;
		Rule rule;
		double prob;

		while(it2.hasPrevious())
		{
			rp = it2.previous();
			rule = rp.getRule();
			prob = rp.getProbability();

			out.write(rule.toString() + ", \t\t" + prob);

			
			out.write("\n");
		}

		out.flush();
		out.close();
	}	

	
	/** 
	 * Generates a {@link Parse} for a given sentence.   
	 * 
	 * @param sentence
	 */
	public Parse<T> parse(Collection<? extends T> sentence) 
	{
		/* create a nersion of the sentence with constituents instead of T's */
		Vector<Constituent> constituentSentence = new Vector<Constituent>();
		for(T token : sentence)
			constituentSentence.add(new RegularConstituent(token));
		
		/* convert the regular grammar to CNF form */
		toCNF();

		/* create and return a parse object */ 
		return new PCFGParse(constituentSentence);
	}
	
	private boolean isTempConst(Constituent c)
	{
		return (c instanceof PCFGrammar<?>.TempConstituent);
	}
	
	/**
	 * Check is the constituent c is a terminal in the current grammar (ie. the
	 * grammar has no rules c -> something.
	 */
	private boolean isTerminal(Constituent c)
	{
		if(c instanceof PCFGrammar<?>.TempConstituent)
			return false;
		return ! fromMap.containsKey(c);
	}
	
	/**
	 * Check if the constituent c is a terminal in the current CNF grammar (ie. the
	 * grammar has no rules c -> something.
	 */
	private boolean isCNFTerminal(Constituent c)
	{
		return ! fromMapCNF.containsKey(c);
	}	
	
	/**
	 * Takes a parse tree and returns the tree with temp constituents removed, and 
	 * the constituent objects turned into basic tokens.
	 * 
	 * @param in	A CNF parse tree (ie. a tree with temporary constituents)
	 * 
	 * @return A Tree with those constituents removed
	 */
	public  Tree<T> reconstruct(Tree<Constituent> in)
	{
		RegularConstituent inRoot; 
		
		if( !isTempConst(in.getRoot().getValue()) )
			inRoot = (RegularConstituent) in.getRoot().getValue();
		else
			throw new IllegalArgumentException("Tree cannot have tempconst for root");
			
		Tree<T> out = new Tree<T>(inRoot.getValue());

		List<Tree<Constituent>.Node> inChildren = in.getRoot().getChildren();
		Iterator<Tree<Constituent>.Node> inIt = inChildren.iterator();

		while(inIt.hasNext())
			reconstruct(inIt.next(), out.getRoot());

		return out;
	}

	/**
	 * Takes a treenode from a tree of constituents, and adds the token from the 
	 * constituent to a new treenode, which is a child of the parameter out.
	 * 
	 * If the treenode in contains a temporary constituent (which doesn't
	 * represent a token T), then the temporary constituent is folded up and 
	 * removed.
	 */
	private void reconstruct(Tree<Constituent>.Node in, Tree<T>.Node out)
	{
		
		List<Tree<Constituent>.Node> inChildren = in.getChildren();

		Tree<T>.Node outChild;

		if(isTempConst(in.getValue()))
		{
			/* If the current out node is a temp constituent, add its children to 
			 * the current node of the regular tree */ 
			for(Tree<Constituent>.Node child : inChildren)
				reconstruct(child, out);
		}else
		{
			/* Otherwise, create a new node in the out tree and recurse with that.
			 */
			outChild = out.addChild( ((RegularConstituent)(in.getValue())).getValue() );
			for(Tree<Constituent>.Node child : inChildren)
				reconstruct(child, outChild);
		}
	}
	
	/**
	 * Represents a rule in Chomsky Normal Form.
	 * 
	 * These are production rules of the form A -> B, C. These symbols are 
	 * referred to as 'from', 'to1' and 'to2' from left to right. 
	 */
	public class CNFRule implements Comparable<CNFRule>
	{
		private Constituent from;
		private Constituent to1;
		private Constituent to2;
	
		/**
		 * Constrcts a rule based on three constituent objects 
		 * 
		 * @param from	The production symbol (on the left of the arrow)
		 * @param to1	The leftmost symbol on the right of the arrow 
		 * @param to2	The rightmost symbol on the right of the arrow
		 */
		public CNFRule(Constituent from, Constituent to1, Constituent to2)
		{
			if(from == null || to1 == null)
				throw new IllegalArgumentException("from or to1 cannot be null");
			
			this.from = from;
			this.to1 = to1;
			this.to2 = to2;
		}
	
		/**
		 * Returns the constituent that defines the left hand part of this rule.
		 * 
		 * @return A Constituent representing the left hand part of this rul.
		 */
		public Constituent getFrom()
		{
			return from;
		}
	
		public Constituent getTo1()
		{
			return to1;
		}
		
		public Constituent getTo2()
		{
			return to2;
		}
		
		public boolean isUnary()
		{
			return to2 == null;
		}
	
		/**
		 * Returns this rule's hashcode.
		 * 
		 * (Code is based on java's hashcode for collections)
		 */
		public int hashCode(){
			int hashCode = 1;
      		hashCode = 31*hashCode + from.hashCode();
      		hashCode = 31*hashCode + to1.hashCode();
      		hashCode = 31*hashCode + (to2==null ? 0 : to2.hashCode());
      		
      		return hashCode;
		}
	
		public boolean equals(Object o){
			
			if(o instanceof PCFGrammar<?>.CNFRule)
			{
				CNFRule r = (CNFRule)o;
				return 
					(r.from.equals(this.from) &&
					 r.to1.equals(this.to1) &&
					 r.to2.equals(this.to2));
			}else
				return false;
		}
	
		/**
		 * Defines an ordering over rules based on the ordering of their string 
		 * representations
		 */
		public int compareTo(CNFRule r){
				return this.toString().compareTo(r.toString());
		}
	
		
		public String toString()
		{
			if(to2 == null) return from + " -> " + to1;
			else return from + " -> " + to1 + " " + to2;
		}
	}
	
	/**
	 * Represents a non-CNF rule. These rules define a production from one symbol
	 * to a non-empty, final set of symbols. For instance A -> B, C, D
	 */
	public class Rule implements Comparable<Rule>
	{
		private RegularConstituent from;
		private Collection<RegularConstituent> to;
		
		/**
		 * Constructs a rule from a single Constituent, and a Collection of 
		 * Constituents. 
		 * 
		 * @param from The Constituent on the left hand side of the production rule.
		 * @param to A collection of Constituents representing the right hand side 
		 * 	of the production rule. The order in which the collection's iterator 
		 * 	returns the constituents defines their order. 
		 */
		public Rule(RegularConstituent from, Collection<RegularConstituent> to)
		{
			this.from = from;
			this.to = to;		
		}
		
		public RegularConstituent getFrom()
		{
			return from;
		}
		
		public Collection<RegularConstituent> getTo()
		{
			return to;
		}
		
		public String toString()
		{
			return from + "->" + to;
		}
		
		/**
		 * Returns the rules' hashcode. 
		 * 
		 * Hashcode algorithm based on that of java's collection's.
		 */
		public int hashCode()
		{
			int hash = 1;
			hash = hash * 31 + from.hashCode();
			hash = hash * 31 + to.hashCode();
			
			return hash;
		}
		
		public boolean equals(Object o)
		{
			if(o instanceof PCFGrammar<?>.Rule)
			{
				Rule r = (Rule)o;
				return (r.from.equals(this.from) &&
						r.to.equals(this.to));
			}
			return false;
		}
		
		public int compareTo(Rule r)
		{
			return this.toString().compareTo(r.toString());
		}		
	}
	
	
	/** 
	 * This abstract class is used to create a common superclass for 
	 * RegularConstituents (which conatin a symbol of type T) and 
	 * TempConstituents which are only used in the creation of the grammar's 
	 * CNF 
	 */
	private abstract class Constituent
	{
	}
	
	/**
	 * A temporary constituent, used in creating the grammar's Chomsky Normal Form.
	 * 
	 *  Since every TempConstituent is unique to a pair single CNFRules, we store 
	 *  these in the object for quick retieval 
	 */
	private class TempConstituent extends Constituent	
	{
		int number;
		String stringRep;
		CNFRule fromRule;
		CNFRule toRule;
		
		public TempConstituent()
		{
			tempConstituents++;
			number = tempConstituents;
			stringRep = "_X" + number;
		}
		
		public int hashCode()
		{
			return stringRep.hashCode();
		}
		
		public String toString()
		{
			return stringRep;
		}
		
		public void setFromRule(CNFRule fromRule)
		{
			this.fromRule = fromRule;
		}
		
		public void setToRule(CNFRule toRule)
		{
			this.toRule = toRule;
		}
		
		/**
		 * @return The rule where this constituent is in the from part
		 */
		public CNFRule getFromRule()
		{
			return fromRule;
		}
		
		/**
		 * @return The rule where this constituent is in the to part
		 */
		public CNFRule getToRule()
		{
			return toRule;
		}

		public boolean equals(Object o)
		{
			if(o instanceof PCFGrammar<?>.TempConstituent)
				return ((TempConstituent)o).stringRep.equals(this.stringRep);
			return false;
		}
		
	}
	
	
	/**
	 * A normal constituent, which maps to a T token.
	 * Used in both the CNFRules and the regular rules
	 */
	
	private class RegularConstituent extends Constituent
	{
		T value;
		public RegularConstituent(T value)
		{
			this.value = value;
		}
		
		public T getValue()
		{
			return value;
		}
		
		public int hashCode()
		{
			return value.hashCode();
		}
		
		public String toString(){
			return value.toString();
		}
		
		public boolean equals(Object o)
		{
			if(o instanceof PCFGrammar<?>.RegularConstituent)
				return ((RegularConstituent)o).value.equals(this.value);
			return false;
		}		
	}
	
	
	/**
	 * Represents a parse from this grammar. 
	 */
	
	private class PCFGParse implements Parse<T>{
		
		/* The 3d vector that will contain the parse values */
		private Vector<Vector<Vector<Node>>> array;
		
		/* The length of the sentence */
		private int n;

		/**
		 * Constructs a parse from the given sentence, according to this grammar
		 * 
		 * @param sentence The sentence to parse
		 */
		public PCFGParse(Collection<Constituent> sentence)
		{
			n = sentence.size();

			/* create the parse chart (as a n x n matrix of empty vectors) */
			initializeArray(n);

			/* ** Phase one: place terminal symbols in bottom row *s* */
			
			Set<CNFRule> rules;
			Node wordNode, node;

			int i = 0;
			
			for(Constituent word : sentence)
			{
				/* Create a parse node for the word. 
				 * These words are never added to the parse chart; they are 
				 * linked to the nodes on the bottom row. */
				wordNode = new Node(word);

				/* Find the rules that could have produced the word */
				if(oneSymbolMap.containsKey(word))
						rules = oneSymbolMap.get(word);
				else 	rules = Collections.emptySet();

				/* Create a node on the bottom row of the parse chart for all 
				 * rules that could have produced the word */
				for(CNFRule rule : rules) 
				{
					node = new Node(rule.getFrom(), getProbability(rule), wordNode);
					array.get(i).get(1).add(node);
				}
				
				i++;
			}

			/* ** Phase two, move up the array ** */

			/* Vectors of nodes to join, and their iterators */
			Vector<Node> nodes1, nodes2; 	
			
			/* Symbols to join in a rule */
			Constituent symbol1, symbol2;
			
			Pair<Constituent, Constituent> key;

			/* All rules joining two s1 and s2 */
			Set<CNFRule> ruleSet;
			
			/* To complete the parse chart, we iterate over three values:
			 */
			
			/* l -- length of the span */
			for(int l = 1; l <= n;l++)
			{
				/* s -- start of span */
				for(int s = 0; s <= (n-l); s++)
				{
					/* k -- partition of span */
					for(int p = 0; p < l; p++)
					{
						/* we now have two points in the array (s, p) and
						 * (s+p, l-p). We need to find all rules that connect
						 * a symbol at (s, p) to a symbol at (s+p, l-p).
						 */

						/* Get all nodes at the first location ... */ 
						nodes1 = array.get(s).get(p);
						/* and from the second */						
						nodes2 = array.get(s+p).get(l-p);

						/* Check all combinations, of these nodes */
						for(Node node1 : nodes1)
						{
							symbol1 = node1.getSymbol();

							for(Node node2 : nodes2)
							{
								symbol2 = node2.getSymbol();

								/* get all rules joining s1 and s2 */
								key = new Pair<Constituent, Constituent>(symbol1, symbol2);
								if(twoSymbolMap.containsKey(key))
									ruleSet = twoSymbolMap.get(key);
								else
									ruleSet = Collections.emptySet();

								/* create a new node for all rules found */
								for(CNFRule rule : ruleSet)
								{
									/* Calculate the 'running probability' at 
									 * this point in the chart. At the top symbol, 
									 * this reprsents the parse probability */
									double probability =
										getProbability(rule) * 
										node1.getProbability() * 
										node2.getProbability();
									
									/* NOTE: We can implement viterbi pruning quite 
									 * simply at this point, to control the size of 
									 * the chart */
									
									node = new Node(rule.getFrom(), probability,	
										node1, node2);
									
									array.get(s).get(l).add(node);
								}
							}
						}
					}
				}
			}
			
			
		}


		/**
		 * Check whether this parse is positive, ie. the sentence is a member
		 * of the grammar. If any symbol in the grammar can produce the sentence
		 * this method returns true (not just if S can produce it).
		 *
		 * @return true is the sentence is a member.
		 */
		public boolean isMember()
		{
			/* If the top-left cell in the parse chart is non-empty then at least 
			 * one parse has been found. */
			return (array.get(0).get(n).size() > 0);
		}


		/**
		 * Returns the number of parses found for the full sentence.
		 *
		 */
		public int numberOfParses()
		{
			/* For every parse found, there is a node in the top left cell of the
			 * parse chart, so the size of that vecotr reprsents the amount of 
			 * parses found*/
			return array.get(0).get(n).size();
		}

		/**
		 * Generate all parses with their probabilities.
		 *
		 * @return A Vector of parse trees, sorted by probability, with the first 
		 * 	parse the most probable.
		 */
		public Collection<Pair<Tree<T>, Double>> allParses()
		{
			Vector<Node> topNodes = array.get(0).get(n);
			Vector<Pair<Tree<T>, Double>> result0 =
				new Vector<Pair<Tree<T>, Double>>(topNodes.size());
			Vector<Tree<T>> result =
				new Vector<Tree<T>>(topNodes.size());

			/* The CNF parse tree */
			Tree<Constituent> tree0;
			/* The cleaned up tree of basic T tokens */
			Tree<T> tree;
			
			double prob;

			/* Iterate over all nodes in the top cell of the parse chart, and 
			 * retrieve the trees that they represent 
			 */
			for(Node top : topNodes)
			{
				tree0 = new Tree<Constituent>(top.getSymbol());

				/* Retrieve the tree from the parse chart */
				makeTree(top, tree0.getRoot());
				
				/* remove tempconstituents, and remove Constituent wrappers,
				 * creating a clean tree of T tokens */
				tree = reconstruct(tree0);
				
				prob = top.getProbability();
				
				result0.add(new Pair<Tree<T>, Double>(tree, new Double(prob)));
			}

			/* Sort by probability */ 
			Collections.sort(result0, new TreeDoubleComparator());

			for(Pair<Tree<T>, Double> pair : result0)
				result.add(pair.getFirst());
			
			return result0;
		}

		/**
		 * Generate all parses starting with a certain symbol, with their
		 * probabilities.
		 *
		 * @param symbol The symbol that the root node should have.
		 * @return A Vector containing parses (as Tree objects).
		 *         
		 */
		public Vector<Tree<T>> allParses(T s0)
		{
			Constituent topSymbol = new RegularConstituent(s0);
			
			Vector<Node> topNodes = array.get(0).get(n);
			Vector<Pair<Tree<T>, Double>> result0 =
				new Vector<Pair<Tree<T>, Double>>(topNodes.size());
			Vector<Tree<T>> result =
				new Vector<Tree<T>>(topNodes.size());

			/* The CNF parse tree */
			Tree<Constituent> tree0;
			/* The cleaned up tree of basic T tokens */
			Tree<T> tree;
			
			double prob;

			/* Iterate over all nodes in the top cell of the parse chart, and 
			 * retrieve the trees that they represent 
			 */
			for(Node top : topNodes)
			{
				if(top.getSymbol().equals(topSymbol))
				{
					tree0 = new Tree<Constituent>(top.getSymbol());
	
					/* Retrieve the tree from the parse chart */
					makeTree(top, tree0.getRoot());
					
					/* remove tempconstituents, and remove Constituent wrappers,
					 * creating a clean tree of T tokens */
					tree = reconstruct(tree0);
					
					prob = top.getProbability();
					
					result0.add(new Pair<Tree<T>, Double>(tree, new Double(prob)));
				}
			}

			/* Sort by probability */ 
			Collections.sort(result0, new TreeDoubleComparator());

			for(Pair<Tree<T>, Double> pair : result0)
				result.add(pair.getFirst());
			
			return result;
		}

		/**
		 * Returns the best parse, according to probability.
		 *
		 * Note: this method is O(n) with n being the total
		 * number of parses for this sentence.(see TODO)
		 *
		 * @return A pair, containing the parse (as a Tree object)
		 *         and the probability as a Double object. null if
		 *		   none are found.
		 */
		public Pair<Tree<T>, Double> bestParse()
		{
			Vector<Node> topNodes = array.get(0).get(n);

			/* the best node found */
			Node topTop = null;
			/* the probability of topTop */
			double prob;
			/* the probability of topProb */
			double topProb = -1.0;

			/* Go through all successful parses, remembering the best one. */
			for(Node top : topNodes)
			{
				prob = top.getProbability();
				if(prob > topProb)
				{
					topProb = prob;
					topTop = top;
				}
			}
			
			if(topTop == null)
				return null;

			Tree<Constituent> tree0 = new Tree<Constituent>(topTop.getSymbol());
			makeTree(topTop, tree0.getRoot());
			Tree<T> tree = reconstruct(tree0); 
			
			return new Pair<Tree<T>, Double>(tree, topProb);
		}

		/**
		 * Returns the best parse, according to probability.
		 *
		 * Note: this method is O(n) with n being the total
		 * number of parses for this sentence.(see TODO)
		 *
		 * @param symbol The symbol that the root node should have.
		 * @return The best parse (as a Tree object). Returns null if none is 
		 * 		found
		 */
		public Tree<T> bestParse(T s0)
		{
			Constituent symbol = new RegularConstituent(s0);
			Vector<Node> topNodes = array.get(0).get(n);

			/* the best node found */
			Node topTop = null;
			/* the probability of topTop */
			double prob;
			/* the probability of topProb */
			double topProb = -1.0;

			/* Go through all successful parses, remembering the best one. */
			for(Node top : topNodes)
			{
				if(top.getSymbol().equals(symbol))
				{
					prob = top.getProbability();
					if(prob > topProb)
					{
						topProb = prob;
						topTop = top;
					}
				}
			}
			
			if(topTop == null)
				return null;

			Tree<Constituent> tree0 = new Tree<Constituent>(topTop.getSymbol());
			makeTree(topTop, tree0.getRoot());
			Tree<T> tree = reconstruct(tree0); 
			
			return tree;
		}

		/**
		 * Turns the parse that can be found under parserNode into treenodes
		 * under tree node.
		 *
		 * When it enters the method, treeNode already represents parserNode.
		 */
		private void makeTree(Node parserNode, Tree<Constituent>.Node treeNode)
		{
			Node backlink1, backlink2;
			Tree<Constituent>.Node node1, node2;

			backlink1 = parserNode.getBackLink1();
			backlink2 = parserNode.getBackLink2();

			/* if the parsernode has no children, return and stop the recursion */
			if(backlink1 == null)
				return;

			node1 = treeNode.addChild(backlink1.getSymbol());
			makeTree(backlink1, node1);

			/* If the parse node has only one child, stop here. */
			if(backlink2 == null)
				return;

			node2 = treeNode.addChild(backlink2.getSymbol());
			makeTree(backlink2, node2);

			return;
		}

		/**
		 * Fills the parse array with empty stuff.
		 *
		 * @param n The size of the sentence
		 */
		private void initializeArray(int n)
		{
			array = new Vector<Vector<Vector<Node>>>(n);
			Vector<Vector<Node>> subarray;

			for(int i = 0; i < n; i++)
			{
				subarray = new Vector<Vector<Node>>(n+1);
				for(int j = 0; j < n + 1; j++)
					subarray.add(new Vector<Node>());
				array.add(subarray);
			}
		}

		/**
		 * Writes
		 *  - the parsematrix
		 *  - all reconstructed parses with probabilities (sorted)
		 *  - all reconstructed parses starting with "top" (sorted)
		 *
		 * Three csv files are created. for this purpose.
		 *
		 * @param n the base filename
		 */
		public void write(File directory, String base) throws IOException
		{
			// parsematrix

			BufferedWriter out = new BufferedWriter(
					new FileWriter(new File(directory, base + ".parsematrix.csv")));

			out.write(this.toString());

			out.flush();
			out.close();

			// all parses
			out = new BufferedWriter(new FileWriter(new File(directory, base + ".parses.csv")));

			Collection<Pair<Tree<T>, Double>> v = allParses();

			for(Pair<Tree<T>, Double> pair : v)
			{
				out.write(pair.getFirst() + ",\t" + pair.getSecond() + "\n");
			}

			out.flush();
			out.close();
			
			out = new BufferedWriter(
					new FileWriter(new File(directory, base + ".CNFRules.csv")));
			
			Iterator<CNFRule> ruleIt = rulesCNF.tokenIterator();
			CNFRule rule;
			while(ruleIt.hasNext())
			{
				rule = ruleIt.next();
				out.write(rule.getFrom() + " -> " + rule.getTo1());
				if(rule.getTo2() != null)
					out.write(" " + rule.getTo2());
				out.write("\t " + rulesCNF.getFrequency(rule)+ "\n");
			}

			out.flush();
			out.close();
		}

		/**
		 * Returns the parse array in string form.
		 */
		public String toString()
		{
			StringBuilder sb = new StringBuilder();

			Iterator<Vector<Vector<Node>>> it1 = array.iterator();
			Vector<Vector<Node>> v2;
			Iterator<Vector<Node>> it2;
			Vector<Node> v3;
			Iterator<Node> it3;

			boolean first1 = true,
			first2,
			first3;

			/* Loop over lines */
			while(it1.hasNext()) 
			{
				if(first1)
					first1 = false;
				else
					sb.append("\n");

				v2 = it1.next();
				it2 = v2.iterator();

				first2 = true;

				/* Loop over cells */
				while(it2.hasNext())
				{
					if(first2)
						first2 = false;
					else
						sb.append(',');

					v3 = it2.next();
					if(v3.size() < 1) sb.append("   ");
					it3 = v3.iterator();

					first3 = true;
					
					/* Loop over cell values */
					while(it3.hasNext()) 
					{
						if(first3)
							first3 = false;
						else
							sb.append(' ');

						sb.append(it3.next());
					}
				}
			}

			return sb.toString();
		}


		/**
		 * Used to store backlinks and probabilities
		 * in the parse array.
		 *
		 * Three nodes can be created: a node containing just a string (for
		 * the words), a node containg one backlink (for the unit production
		 * rules) or a node containing two backlinks for the regular rules
		 */
		private class Node
		{
			private Constituent symbol;
			private double probability;
			private Node bl1, bl2;

			public Node(Constituent word)
			{
				this.symbol = word;
			}

			public Node(Constituent word, double probability, Node backlink)
			{
				this.symbol = word;
				this.probability = probability;
				this.bl1 = backlink;
			}

			public Node(Constituent word, double probability, Node backlink1, Node backlink2)
			{
				this.symbol = word;
				this.probability = probability;
				this.bl1 = backlink1;
				this.bl2 = backlink2;
			}

			public Constituent getSymbol()
			{
				return symbol;
			}

			public double getProbability()
			{
				return probability;
			}

			public Node getBackLink1()
			{
				return bl1;

			}

			public Node getBackLink2()
			{
				return bl2;
			}

			public String toString()
			{
				return symbol.toString();
			}
		}

		/**
		 * Used to sort the list of parses by probability. 
		 */
		private class TreeDoubleComparator
		implements Comparator<Pair<Tree<T>, Double>>
		{
			public int compare(Pair<Tree<T>, Double> p1, Pair<Tree<T>, Double> p2)
			{
				int c = p1.getSecond().compareTo(p2.getSecond());

				return -c;
			}
		}
	}

	/**
	 * Stores combinations of NGrams and their probabilities.
	 */
	private class RuleProbability implements Comparable<RuleProbability>
	{
		private final Rule rule;
		private final double probability;

		public RuleProbability(Rule rule){
			this.rule = rule;
			this.probability = PCFGrammar.this.getProbability(rule);
		}

		public String toString()
		{
			return rule + ", " + probability;
		}

		public Rule getRule()
		{
			return rule;
		}

		public double getProbability()
		{
			return probability;
		}

		public int compareTo(RuleProbability o)
		{
			return (int)Math.signum(probability - o.probability);

		}
	}
	
	public static void main(String[] args)
	throws IOException
	{
		PCFGrammar<String> g = TestGrammars.adriaansVervoort();
		File outFile = new File("./output/pcfg_grammar_test/");
		outFile.mkdirs();
			
		g.write(outFile, "toygrammar");
		
		long t0, td;
		t0 = System.currentTimeMillis();
		ArrayList<String> sentence;
		
		for(int i = 0; i < 10; i++)
		{
			Tree<String> tree = g.generateTree("S", 0, 4, null);
			
			System.out.println(tree.getLeaves());
			System.out.println(tree);
			// System.out.println(g.parse(tree.getLeaves()).bestParse());
			System.out.println();
			
		}
		
		td = System.currentTimeMillis() - t0;
		 
		System.out.println("Time taken " + ((double)(td))/(1000.0) + "s");
	}
}
